tips.jit <- sapply(1:ncol(tips), function(j) if(j<3) tips[,j] else jitter(tips[,j], factor=.5))
colnames(tips.jit) <- colnames(tips)
splom(tips.jit, pch=16, col=tips.col, cex=.5, alpha=.5) # Thanks, Josh!
# Aesthetics of labels and axes:
splom(tips.jit, pch=16, col=tips.col, varname.cex=.8, axis.text.cex=.5, axis.line.tck=.5, pscales=4)
# Coplot version:
splom(~cbind(tips[,c("TOTBILL","TIP")],DAY=jitter(tips[,"DAY"])) | SEX*SMOKER, data=tips.df)
splom(~cbind(tips[,c("TOTBILL","TIP")],DAY=jitter(tips[,"DAY"])) | SEX*SMOKER, data=tips.df,
pch=16, varname.cex=.8, axis.text.cex=.5, axis.line.tck=.5, pscales=4, xlab="") # Aethetics!
# Q: How many data dimensions are you 'looking at' in each display?
# PARALLEL COORDINATE PLOTS:
par(mfrow=c(1,1))
parcoord(tips)       # 'MASS'
library(MASS)
# PARALLEL COORDINATE PLOTS:
par(mfrow=c(1,1))
parcoord(tips)       # 'MASS'
parallelplot(tips)   # 'lattice', random colors by default
parallelplot(tips, horizontal.axis=F)   # left-to-right
parallelplot(tips.jit, horizontal.axis=F, col=tips.col)  # meaningful colors
# Coplot version enabled by 'lattice':
parallelplot(~ tips.jit[,-c(3,4)] | SEX*SMOKER, data=tips.df,
horizontal.axis=F, varname.cex=.8,
groups=DAY)                                       # Selects default colors for 'groups'
parallelplot(~ tips.jit[,-c(3,4)] | SEX*SMOKER, data=tips.df,
horizontal.axis=F, varname.cex=.8,
groups=DAY, col=c("red","purple","blue","green")) # Choose your own colors for groups.
# COLORS in 'lattice':
# - This library tries to provide good default colors.
#   You may or may not agree.
# - Colors for cases are conveyed by using the argument
#     'groups=...".  Default colors will be chosen.
# - If you want to use your own colors, use in addition the argument
#     'col=...".  Its values will be matched to 'groups=...'.
# - If you are NOT CONDITIONING, then just using 'col=...' will work
#     just like in 'base' graphics.
#     In 'lattice' IT WILL NOT WORK PROPERLY IF YOU CONDITION!!!!!!
burg.dich <- read.csv("http://www-stat.wharton.upenn.edu/~buja/DATA/burg_dich.csv", header=T)
# First glance:
str(burg.dich)
tab.all(burg.dich)
# Plot Earnings
earnings <- burg.dich[,"earnings"]
earnings
# We find some strangely heavy tails:
par(mgp=c(1.5,.5,0), mar=c(3,3,2,1))
hist(earnings, col="gray", breaks=100)
# Where are these extreme negative values?  List them:
sort(earnings)[1:20]          # Lower end.
rev(sort(earnings))[1:20]     # Upper end.
# Based on the extremes, let's limit earnings to +-10:
sel <- (-10) < earnings & earnings < 10
hist(earnings[sel], col="gray", breaks=100)
# Still, very heavy-tailed.  Subselect the middle 80% of earnings:
lower <- quantile(earnings, 0.1)   # Lowest decile.
upper <- quantile(earnings, 0.9)   # Highest decile.
earnings.sub <- earnings[lower < earnings & earnings < upper]
hist(earnings.sub, col="gray")
# Ok, we like to see this: earnings have a mode in the positive range.
# But there is left-skewness, which means that there are many more
# extreme negative earnings than extreme positive earnings:
# Earnings can drop faster than rise, which makes sense.
# To get back to our story: let's use unreasonably narrow bins.
hist(earnings.sub, breaks=100, col="gray")
# Or even more extreme:
hist(earnings.sub, breaks=1000, col="gray")
65+45 + 65 + 60+45+60+65+35+90+85+50+65+50+65
845/14
x=c(35     \ 45 \ 45 \ 	50 \  50 \  60 \  \textbf{60 65}  \ 65 \ 65  \ 65 \ 65 \ 85 \ 90)
x=c(65,45,65,60,45,60,65,35,90,85,50,65,50,65)
mean(x)
sd(x)
sd(x)*sqrt(13)/sqrt(14)
65+45 + 65 + 60+45+60+65+85+50+65+50+65
720/12
(1806-86)/20
(1806-155)/20
10/99*360
data(Titanic);  help(Titanic)
titanic <- read.table("http://www-stat.wharton.upenn.edu/~buja/DATA/titanic.dat", header=T)
str(titanic)
heads(titanic)
head(titanic)
titanic
titanic <- read.table("http://www-stat.wharton.upenn.edu/~buja/DATA/titanic.dat", header=T)
str(titanic)
dimnames(table(titanic))
dimnames(Titanic)
#----
# Barplot/chart functions
barplot       # 'base'
barchart      # 'lattice'
# First experiments with barplot():
barplot(table(titanic[,"Class"]))     # From dataframe
barplot(margin.table(Titanic,1))      # From contingency table
barplot(table(titanic[,c("Sex")]))    # From dataframe
barplot(margin.table(Titanic,2))      # From contingency table; reverse ordering
barplot(table(titanic[,c("Sex")]))    # From dataframe
barplot(margin.table(Titanic,2))      # From contingency table; reverse ordering
barplot       # 'base'
barchart      # 'lattice'
# First experiments with barplot():
barplot(table(titanic[,"Class"]))     # From dataframe
barplot(margin.table(Titanic,1))      # From contingency table
barplot(table(titanic[,c("Sex")]))    # From dataframe
barplot(margin.table(Titanic,2))      # From contingency table; reverse ordering
# Same with barchart:
barchart(table(titanic[,"Class"]))    # Oops, why this default?
barchart(table(titanic[,"Class"]))    # Oops, why this default?
library(lattice)
library(MASS)
library(lattice)
barchart(table(titanic[,"Class"]))    # Oops, why this default?
barchart(margin.table(Titanic, 1))    # Dito
barchart(table(titanic[,"Class"]), horizontal=F)
# The 'lattice' default for horizontal bars is visually not good for bar comparison:
# We are better at vertical height comparisons than horizontal width comparisons.
# Reason: Our vision is trained for detail on a horizontal horizon.
# The only reason for horizontal bars would be legibility of horizontal labels.
# Horizontal labels on the x-axis get crowded if there are many,
# and vertical labels cause our heads to tilt for reading.
#----
# 2D BARCHARTS: DIVIDED AND NESTED BARCHARTS:
# - DIVIDED BARCHARTS: barplot() accepts matrices
#   and uses their columns for 'stacked/divided barcharts':
barplot(table(titanic[,c("Survived","Class")]))  # From dataframe
barplot(margin.table(Titanic,c(4,1)))            # From contingency table
#   Need a legend to make sense of what is being plotted:
barplot(table(titanic[,c("Survived","Class")]), legend.text=T)  # Ooops
#   Aesthetics:
par(mar=c(3,3,5,2))
barplot(table(titanic[,c("Survived","Class")]),
col=c("gray70","gray90"), main="Survival on the Titanic by Class",
legend.text=c("perished","survived"), args.legend=list(x="topleft") )
#
# - NESTED BARCHARTS:
barplot(table(titanic[,c("Survived","Class")]), beside=T)
barplot(table(titanic[,c("Survived","Sex")]), beside=T)
# - Comparison of divided and nested:
par(mfrow=c(2,2), mgp=c(1.5,.5,0), mar=c(3,3,2,2), oma=c(0,0,3,0)) # Outer margin for title!!!
barplot(table(titanic[,c("Survived","Class")]), legend=T, args.legend=list(x="topleft"))
barplot(table(titanic[,c("Survived","Sex")]))
barplot(table(titanic[,c("Survived","Class")]), beside=T)
barplot(table(titanic[,c("Survived","Sex")]), beside=T)
title("Divided and Nested Barcharts", outer=T, cex.main=1.5)   # Title in outer margin
#   Divided barcharts:
#   . Facilitated comparisons:
#     + overall category counts
#     + first subcategory counts (here: perished)
#     + NOT: second and other subcategories (because they are shifted)
#   . Aesthetics are simple, fewer plotted bars
#   Nested barcharts:
#   . Faciliated comparisons:
#     + all subcategory counts
#     + NOT: overall category counts
#   . Aesthetics are more complex, more plotted bars
#----
# COPLOTS WITH BARCHARTS:
# barchart() in 'lattice' gives you much flexibility for conditionaing and layout:
#   refine...
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic))
# The instructor has no idea what the bar dividers are...  Anyone?
par(mfrow=c(2,2), mgp=c(1.5,.5,0), mar=c(3,3,2,2), oma=c(0,0,3,0)) # Outer margin for title!!!
barplot(table(titanic[,c("Survived","Class")]), legend=T, args.legend=list(x="topleft"))
barplot(table(titanic[,c("Survived","Sex")]))
barplot(table(titanic[,c("Survived","Class")]), beside=T)
barplot(table(titanic[,c("Survived","Sex")]), beside=T)
title("Divided and Nested Barcharts", outer=T, cex.main=1.5)   # Title in outer margin
#   Divided barcharts:
#   . Facilitated comparisons:
#     + overall category counts
#     + first subcategory counts (here: perished)
#     + NOT: second and other subcategories (because they are shifted)
#   . Aesthetics are simple, fewer plotted bars
#   Nested barcharts:
#   . Faciliated comparisons:
#     + all subcategory counts
#     + NOT: overall category counts
#   . Aesthetics are more complex, more plotted bars
#----
# COPLOTS WITH BARCHARTS:
# barchart() in 'lattice' gives you much flexibility for conditionaing and layout:
#   refine...
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic))
# The instructor has no idea what the bar dividers are...  Anyone?
#   Another problem: baseline is negative .... !!!! BUG !!!
# Nested/grouped barcharts: nesting is by 'groups=...'
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived)   # default: 'stack=F'
# Divided/stacked barcharts: dividing is by 'groups=...'
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic))
# The instructor has no idea what the bar dividers are...  Anyone?
#   Another problem: baseline is negative .... !!!! BUG !!!
# Nested/grouped barcharts: nesting is by 'groups=...'
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived)   # default: 'stack=F'
# Divided/stacked barcharts: dividing is by 'groups=...'
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived,
stack=T)
# With legend: Justin the stickler -- No/Yes vs Yes/No ... how invert?
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived,
stack=T,
auto.key=list(title="Survived") )
# Legend horizontal in 2 columns:
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived,
stack=T,
auto.key=list(title="Survived", columns=2) )
# Force four plots into a row:
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived,
stack=T,
auto.key=list(title="Survived", columns=2),
layout=c(4,1))
# Play with aspect ratio:
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived,
stack=T,
auto.key=list(title="Survived", columns=2),
layout=c(4,1),
aspect=1.5)
# Allow separate scales on the vertical axes:
barchart(Freq ~ Class| Sex + Age, data=as.data.frame(Titanic),
groups= Survived,
stack=T,
auto.key=list(title="Survived", columns=2),
layout=c(4,1),
scales=list(y="free") )
# Final question: How-Many-D are these plots:
#================================================================
mosaicplot(Titanic)    # How on earth do you decipher this?
mosaicplot(~ Sex + Class + Survived, dir=c("v","v","h"), data=Titanic, off=1)
# - Rule: The most interpretable mosaic plot has one vertical variable and
#         one or more nested horizontal variables
#         ==> 'doubledecker plot' (Heike Hofmann)
# - The 'vcd' package has a doubledecker plot:
library(vcd)
doubledecker(Survived ~ Sex + Class, data=Titanic)
# - The instructor's mosaic plot:
mosaicplot(Titanic)    # How on earth do you decipher this?
mosaicplot(~ Sex + Class + Survived, dir=c("v","v","h"), data=Titanic, off=1)
mosaicplot(Titanic)    # How on earth do you decipher this?
mosaicplot(~ Sex + Class + Survived, dir=c("v","v","h"), data=Titanic, off=1)
library(vcd)
doubledecker(Survived ~ Sex + Class, data=Titanic)
# - The instructor's mosaic plot:
source("http://www-stat.wharton.upenn.edu/~buja/STAT-541/mosaic.R")
# ignore the complaint; else do this:     detach("package:vcd")
mosaic(titanic[,c("Sex","Class","Survived")])     # from dataframe
mosaic.plot(Titanic, dims=c("Sex","Class","Survived")) # from contingency table (array)
# - 'lattice': No mosaic plots apparently...
mosaic.matrix(titanic)   # dataframe
mosaic.matrix(Titanic)   # contingency table
mosaic.matrix(titanic)   # dataframe
mosaic.matrix(Titanic)   # contingency table
#     Q: Are symmetric cells the 45 degree reflections of each other?
#----------------------------------------------------------------
# MARKETING DATA: PROFILING CUSTOMER SEGMENTS
# Telecom marketing data (instructor's source):
mktg <- read.table("http://www-stat.wharton.upenn.edu/~buja/DATA/mktg.dat", header=T)
# First glance:
str(mktg)      # 3 quantitative variables for customer intensity; 5(6) categorical covariates
tab.all(mktg)
# Will need a version with categorials coded as factors:
mktg.df <- mktg
mktg.df[,"biz"]   <- factor(mktg[,"biz"],   levels=c(0,1), labels=c("biz.No",  "biz.Yes"))
mktg.df[,"reach"] <- factor(mktg[,"reach"], levels=c(0,1), labels=c("reach.No","reach.Yes"))
mktg.df[,"kids"]  <- factor(mktg[,"kids"],  levels=c(0,1), labels=c("kids.No", "kids.Yes"))
tmp <- su(mktg.df[,"age"])               # su <- function(x) sort(unique(x))
mktg.df[,"age"]   <- factor(mktg[,"age"],   levels=tmp, labels=paste("age",tmp,sep="."))
tmp <- su(mktg.df[,"edu"])
mktg.df[,"edu"]   <- factor(mktg[,"edu"],   levels=tmp, labels=paste("edu",tmp,sep="."))
tmp <- su(mktg.df[,"seg"])
mktg.df[,"seg"]   <- factor(mktg[,"seg"],   levels=tmp, labels=paste("seg",tmp,sep="."))
# HISTOGRAMS:
windows(width=3, height=10)
par(mfrow=c(ncol(mktg),1), mgp=c(1.5,0.5,0), mar=c(3,3,2,1)) # Shrink waste...
for(i in 1:ncol(mktg)) hist(mktg[,i])
# Looks nasty.
# Refine and improve: 2 columns, one with normal bins, one with narrow bins.
windows(width=8, height=10)
par(mfrow=c(ncol(mktg),2), mgp=c(1.5,.5,0), mar=c(2,3,1,1))
for(i in 1:ncol(mktg)) {
pairs(mktg)
pairs(mktg)
pairs(mktg)
source('~/.active-rstudio-document')
pairs(mktg, gap=.1, pch=16, cex=.5)
}
pairs(mktg)
pairs(mktg, gap=.1, pch=16, cex=.5)
plot(as.data.frame(mktg), gap=.1, pch=".", cex=.5)
# Instructor's function: jitter variables with few values, adds space around points
pairs.plus(mktg)          # source(....)  # see above
pairs.plus(mktg, gap=.1, pch=".")
#----
# MOSAIC PLOTS:
# While profiling the segments was the primary practical concern
# for this dataset, one should also be interested in the relationship
# between the observed variables ('in.',...,'edu').
# A variable of primary interest to a business is the revenue from each
# custormer, hence we may want to see whether there exist differences in
# revenue between groups defined in terms of 'bus','reach','kids'.
# Here is a histogram-based coplot of the 8 groups defined by all
# possible combinations of levels of these three categorical variables:
# Marketers should keep in mind how little bottom line differences
# there are.
#----
# - Sometimes it is worthwhile to discretize a continuous variable
#   to a categorical variable, if for no other reason than making
#   it accessible to the power of mosaic plots.
#
#   (If discretizing turns continuous into categorical variables,
#    recall that jittering did somewhat the opposite: turning
#    categorical/ordered variables into continuous ones.)
#
#   In the marketing data, we will do the following:
#   * We will treat "revenue" as a response and try to describe its
#     association with other variables: "reach", "kids", "bus", "age", and "edu".
#     To this end, we will break "revenue" into 3 equal brackets.
#   * We will then use mosaic plots to profile the segments in terms of the
#     other categorical variables, including discretized "revenue".
#
# - We ignore incoming/outgoing calls and discretize "revenue"
#   to a categorical  variable.
#   Hand-craft a contingency table with self-explanatory labels:
#
#   1) Break "revenue" into 3 categories according to terciles:
mktg.rev <- cut(mktg[,3],
breaks=c(-Inf, quantile(mktg[,3],c(1/3,2/3)), Inf),
labels=c("-rev","~rev","+rev"))
#      The function 'cut()' is meant for such purposes.  One gives it the
#      vectors of breaks (here computed as terciles
#   2) Convert the categorical variables (coded by positive integers
#      in columns 4 through 9 in 'mktg') to factors with self-explanatory
#      labels for the categories.  For example
mktg.bus   <- factor(mktg[,4], levels=0:1, labels=c("-bus","+bus"))
mktg.reach <- factor(mktg[,5], levels=0:1, labels=c("-reach","+reach"))
mktg.kids  <- factor(mktg[,6], levels=0:1, labels=c("-kids","+kids"))
mktg.age   <- factor(mktg[,7], levels=0:4,
labels=paste("age",1:5,sep=""))
mktg.edu   <- factor(mktg[,8], levels=0:6,
labels=paste("edu",1:7,sep=""))
mktg.seg   <- factor(mktg[,9], levels=1:4,
labels=paste("seg",1:4,sep=""))
#   Now throw all these factors into the tabulation:
mktg.tab <- table(rev=mktg.rev, bus=mktg.bus, reach=mktg.reach,
kids=mktg.kids, age=mktg.age, edu=mktg.edu,
seg=mktg.seg)
#   This table is quite high-dimensional:
dim(mktg.tab)
#   This shows that we have 7 dimensions with the following number of
#   groups in each dimension: 3, 2, 2, 2, 5, 7, 4,
#   The following shows the names of the levels/groups/categories for
#   each dimension:
dimnames(mktg.tab)
#
#   For a table this size, plotting all dimensions doesn't work.
#   Here is more clarity:
#   - Look at the 'rev' as a function of 'kids' within 'reach' within 'bus':
mosaic.plot(mktg.tab, dims=c("bus","reach","kids","rev"))
#   - It may make sense to a few different nestings to see potential patterns
#     in how 'rev' depends on 'bus', 'reach', 'kids':
windows(15,10)
par(mfrow=c(2,3))
mosaic.plot(mktg.tab, dims=c("bus","reach","kids","rev"), cex=.8)
mosaic.plot(mktg.tab, dims=c("reach","bus","kids","rev"), cex=.8)
mosaic.plot(mktg.tab, dims=c("bus","kids","reach","rev"), cex=.8)
mosaic.plot(mktg.tab, dims=c("kids","bus","reach","rev"), cex=.8)
mosaic.plot(mktg.tab, dims=c("reach","kids","bus","rev"), cex=.8)
mosaic.plot(mktg.tab, dims=c("kids","reach","bus","rev"), cex=.8,
mar=c(0,0,2,0),main="gaga")
#   The most patterned plot may be the last: it shows that
#     the fraction of high-revenue households (blue bars) increases and
#     the fraction of low-revenue households (brown bars) decreases
#     . from '-bus' to '+bus', that is, with business needs,
#     . from '-reach' to '+reach', that is, with reach needs,
#     . both for '-kids' and '+kids', that is, households with and without children.
#   It seems that business and reach needs are slight drivers of high revenue.
#
#   The Hartigan-Kleiner mosaic plots: turns out to be useful!
windows()
hlep(windowa)
hlep(windows)
help(windows)
quartz()
mosaic.plot(mktg.tab, dims=c("bus","reach","kids","rev"),
hor.vert=c("h","v","h","v"), cex=.8, lab.dist.vert=.2, border=T)
#   Interesting observation:
#   - The four large blocks are broken almost cross-wise.
#   - This means that all proportions are roughly equal across the
#     'reach' and 'bus' conditions.
cor.xy <- .05;  N <- 10000
x <- rnorm(N)
y <- cor.xy * x + sqrt(1-cor.xy^2) * rnorm(N)
cor(x,y)
#
#   Next discretize x and y:
x.categ <- cut(x,
breaks=c(-Inf,quantile(x,c(1/3,2/3)),Inf),
labels=c("low.x","mid.x","high.x"))
y.categ <- cut(y,
breaks=c(-Inf,quantile(y,c(1/3,2/3)),Inf),
labels=c("low.y","mid.y","high.y"))
#
#   Finally compare a scatterplot of y versus x with a mosaic plot
#   of y.categ versus x.categ:
#      windows(15,7.5)
#      windows(w=16, h=8)
par(mfrow=c(1,2))
plot(x,y, pch=16, cex=.2, xlim=c(-4,4), ylim=c(-4,4))
mosaic.plot(table(x.categ, y.categ),
lab.dist.hor=.2, lab.dist.vert=.2, cex=.8)
#   Can you see the correlation in the scatterplot?  The mosaic plot?
#   [If the trend in the mosaic plot seems wrong, think about it.
#   It does reflect a positive correlation.]
#
# [ Does not work in the current R
#   Animation:
#     You can wrap a for-loop around the statements of this section
#     and execute them a 100 or so times.
#       But comment out the 'windows(...)' statement to avoid creating
#     of standard normal data of size N and with true correlation 0.05.
#     You can now ask how often you see a correlation in the scatterplot
#     and how often a corresponding trend in the mosaic plot.
#     For the overwhelming majority of samples you will
#     NOT SEE the correlation in the scatterplot, but you will
#     SEE it in the mosaic plot.
# ]
#     Raising the question of sampling variability brings us
#     to problems of statistical inference:
#
#                IS WHAT WE SEE REAL?
#
# Here is an inferential version that provides an independence test:
mosaic.plot.overallnull(data.frame(x=x.categ, y=y.categ), nrand=10,
lab.dist.hor=.2, lab.dist.vert=.2, cex=.8)
#----------------------------------------------------------------
# LECTURE 6 -- 2012/09/24
# * ORG:
#   - taped lecture of 9/17 is at
#     http://web.wharton.upenn.edu/instruction/?method=media&action=edit&video_id=30292
#   - HW 2: bang up on ggobi
#           How'd it go?
# * RECAP:
#   - the power of mosaic plots
#     usually remain with the simplest version: 1 Y (doubledecker plot)
#   - highly interactive and dynamic data visualization: ggobi
#----------------------------------------------------------------
# INTERACTIVE DATA VISUALIZATION SOFTWARE:
# - Example demonstrated: ggobi
#     [Data examples: tips, places]
#   Other software examples with different focus:  manet
# - Some commercial software packages contain such features:
#   . JMP (from SAS, John Sall''s project)
#   . Datadesk (Velleman)
# - Fundamental operations:
#   . painting/brushing in linked plots
#   . dynamic projections, in particular 3D rotations,
#     but also grand tours, correlation tours, regression tours
#   . scaling
#   . others: subsampling, transforming, ...
# - The modern challenge: MANY VARIABLES   (large p versus large N)
#   . Example: Association Navigator
# - Other areas for dynamic visualization:
#   . maps
#   . analytic graphs
# - What does it take to program your own dynamic viz?
#   . R: Simple identifications can be done with 'identify()'
cars <- read.table("http://stat.wharton.upenn.edu/~buja/STAT-541/CarModels2003-4-NA.TXT",
header=T, sep=",", na=".")
plot.plus(cars[,c("Horsepower","MPG.Highway")], extra=.2)  # For more space around points
identify(cars[,c("Horsepower","MPG.Highway")], labels=cars[,"Model"]) # Hit ESC to stop
cars <- read.table("http://stat.wharton.upenn.edu/~buja/STAT-541/CarModels2003-4-NA.TXT",
header=T, sep=",", na=".")
plot.plus(cars[,c("Horsepower","MPG.Highway")], extra=.2)  # For more space around points
identify(cars[,c("Horsepower","MPG.Highway")], labels=cars[,"Model"]) # Hit ESC to stop
cars <- read.table("http://stat.wharton.upenn.edu/~buja/STAT-541/CarModels2003-4-NA.TXT",
header=T, sep=",", na=".")
plot.plus(cars[,c("Horsepower","MPG.Highway")], extra=.2)  # For more space around points
identify(cars[,c("Horsepower","MPG.Highway")], labels=cars[,"Model"]) # Hit ESC to stop
for(i in 1:5) { xy <- locator(n=1);  points(xy, pch=16, cex=2, col="red") } # Hit ESC to stop sooner
for(i in 1:5) { xy <- locator(n=1);  abline(v=xy$x, col="red");  abline(h=xy$y, col="red") }
A=c
a=c(1,1,0,0)
dim(a)=c(2,2)
eigen(a)
a=c(1,1,1,1)
dim(a)=c(2,2)
eigen(a)
places <- read.table("http://www-stat.wharton.upenn.edu/~buja/STAT-541/places.dat")
places <- read.table("../A-STAT-541/Data/places.dat")
str(places)
places <- read.table("../A-STAT-541/Data/places.dat")
str(places)
#     Housing costs:
qqnorm(places[,"Housing"])
source("http://www-stat.wharton.upenn.edu/~buja/STAT-541/qqplot.R")
source("../A-STAT-541/Functions/qqplot.R")
qqnorm.null.conf(places[,"Housing"], box.cox.par=0)
places <- read.table("../A-STAT-541/Data/places.dat")
. Population parameters:
mu.vec :=  E[X.vec]                                            (px1)
X.mat
library(HistData)
help(HistdData)
help(HistData)
install.packages("HistData")
library(HistData)
install.packages("~/Desktop/tsvd_1.3.tgz", repos = NULL)
