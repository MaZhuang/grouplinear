c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(x,v,group)
delta.dynamic
n
bat$X1
1/(4 * bat$N1)
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero
tse.gl.dynamic[j]
tse.gl.sure[j]
tse.gl.ol[j]
rel.tse.breaks
tse.SG.all <- mean(tse.SG)
bat.perm <- function(){#
  bat <- bat.raw[1:20,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE,col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))
group
c=DynamicSure(bat$X1,1/(4 * bat$N1))
position=c[[1]]
n=dim(position)[1]
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero
bat.perm <- function(){#
  bat <- bat.raw[1:20,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE,col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))
bat.perm <- function(){#
  bat <- bat.raw[1:20,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}
j=1
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
# grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero
# XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero
# group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero
# oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)
# URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE,col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))
min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)
sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))
for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }
sure.grouplinear <- function(x,v,nbreak){ #nbreak=num of bins#
	n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n#
}
for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)
x
x=bat$X1
v=1/(4 * bat$N1)
nbreak=2
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n
nbreak=3
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n
nbreak=10
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)
suresub <- mapply(sure.spher,xsub,vsub)   #modified
sum(suresub)/n
suresub
sure.spher <- function(x.,v.){#
  n. <- length(x.)#
 # cstar <- max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0) ##modified#
  if (n.==0) {0 #
  } else if ( (n.<3) ) {sum(v.)  #| (var(x.)==0) #
  }#
  else if (max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0)==0){#
  	sum(v.) #
  }#
  else if (var(x.)==0){#
  	(2-n.)/n.*sum(v.)+sum((x.-mean(x.))^2)#
  }#
  else {	# can set sure to an arbitrary value if var(x.)=0, since this event is of measure zero#
	cstar <- max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0) ##modified#
	b <- cstar * mean(v.)/var(x.)#
    b <- min(1,b)#
	db <- -cstar * mean(v.)/(var(x.))^2 * as.numeric( cstar * mean(v.)/var(x.) < 1 )###
	sum(   v. + ( b * (x.-mean(x.)) )^2 - 2 * v. * (  (1-1/n.) * b + 2 * (x.-mean(x.))^2 * db/(n.-1)  )   )#
	}#
}
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n
# Group-linear Functions#
#
# "2014-11-13 11:33:34 EST"#
#
## spherically symmetric estimator with c_n = c^*_n#
spher <- function(x.,v.){#
n. <- length(x.)#
if ( (n.==1) | (var(x.)==0) ) x. else {#
	cstar <- max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0)#
	bhat <- min( cstar*mean(v.)/var(x.), 1 )#
	x. - bhat*(x. - mean(x.))#
	}#
}#
## spherically symmetric estimator with c_n = c^*_n, shrinkage toward zero#
spher.zero <- function(x.,v.){#
  n. <- length(x.)#
  cstar <- max( 1-2*( max(v.)/mean(v.) )/n., 0)#
  bhat <- min( cstar*mean(v.)/mean(x.^2), 1 )#
  (1- bhat)*x.#
}#
#
## function that returns the common bhat (replicated)#
spher.bhat <- function(x.,v.){#
  n. <- length(x.)#
  if ( (n.==1) | (var(x.)==0) ) x. else {#
    cstar <- max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0)#
    bhat <- min( cstar*mean(v.)/var(x.), 1 )#
    return(rep(bhat,n.))#
  }#
}#
#
## group-linear estimator#
#
grouplinear <- function( x,v,nbreak=floor(length(x)^(1/3)) ){  # default: bin log(v) into same NUMBER (=n^(1/3) of intervals#
  n <- length(x)#
  splitby=cut(log(v),breaks=nbreak, labels=F)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	indexsub <- split(1:n,splitby)#
	thetahatsub <- mapply(spher,xsub,vsub)#
	indexsub.unlist <- as.vector( unlist(indexsub) )#
	thetahatsub.unlist <- as.vector( unlist(thetahatsub) )#
	thetahat <- thetahatsub.unlist[order(indexsub.unlist)]	#
	return(thetahat)#
}#
#
## group-linear estimator with shrinkage toward zero#
#
grouplinear.zero <- function( x,v,nbreak=floor(length(x)^(1/3)) ){  # default: bin log(v) into same NUMBER (=n^(1/3) of intervals#
  n <- length(x)#
  splitby=cut(log(v),breaks=nbreak, labels=F)#
  xsub <- split(x,splitby)#
  vsub <- split(v,splitby)#
  indexsub <- split(1:n,splitby)#
  thetahatsub <- mapply(spher.zero,xsub,vsub)#
  indexsub.unlist <- as.vector( unlist(indexsub) )#
  thetahatsub.unlist <- as.vector( unlist(thetahatsub) )#
  thetahat <- thetahatsub.unlist[order(indexsub.unlist)]	#
  return(thetahat)#
}#
#
# # ## example#
# n <- 300#
# v <- runif(n,.1,1)#
# theta <- v-mean(v)#
# x <- rnorm(n,theta,sd=sqrt(v))#
# grouplinear(x,v)#
# mean( (grouplinear(x,v)-theta)^2 )   #
# mean( (grouplinear.zero(x,v)-theta)^2 )   #
## sure for grouplinear estimator#
#
sure.spher <- function(x.,v.){#
  n. <- length(x.)#
 # cstar <- max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0) ##modified#
  if (n.==0) {0 #
  } else if ( (n.<3) ) {sum(v.)  #| (var(x.)==0) #
  }#
  else if (max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0)==0){#
  	sum(v.) #
  }#
  else if (var(x.)==0){#
  	(2-n.)/n.*sum(v.)+sum((x.-mean(x.))^2)#
  }#
  else {	# can set sure to an arbitrary value if var(x.)=0, since this event is of measure zero#
	cstar <- max( 1-2*( max(v.)/mean(v.) )/(n.-1), 0) ##modified#
	b <- cstar * mean(v.)/var(x.)#
    b <- min(1,b)#
	db <- -cstar * mean(v.)/(var(x.))^2 * as.numeric( cstar * mean(v.)/var(x.) < 1 )###
	sum(   v. + ( b * (x.-mean(x.)) )^2 - 2 * v. * (  (1-1/n.) * b + 2 * (x.-mean(x.))^2 * db/(n.-1)  )   )#
	}#
}#
sure.spher.zero <- function(x.,v.){#
  if (n.==0) {0 #
  }else if ( (n.==1) | (var(x.)==0) ) {sum(v.) #
  }else {	# can set sure to an arbitrary value if var(x.)=0, since this event is of measure zero#
    cstar <- 1-2*max(v.)/sum(v.) * ( 1-2*max(v.)/sum(v.) > 0 )#
    b <- cstar * mean(v.)/mean(x.^2)#
    b <- min(1,b)#
    db <- -cstar * mean(v.)/mean(x.^2)^2 * ( cstar * mean(v.)/mean(x.^2) < 1 )#
    sum(   v. + ( b * (x.) )^2 - 2 * v. * (  b + 2 * x.^2 * db/n.  )   )#
  }#
}#
sure.grouplinear <- function(x,v,nbreak){ #nbreak=num of bins#
	n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n#
}#
#
sure.grouplinear.zero <- function(x,v,nbreak){ #nbreak=num of bins#
  n <- length(x)#
  splitby=cut(log(v),breaks=nbreak)#
  xsub <- split(x,splitby)#
  vsub <- split(v,splitby)#
  suresub <- mapply(sure.spher.zero,xsub,vsub)#
  sum(suresub)/n#
}
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE,col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSEï¼Œcol.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE,col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE,col.names=c('tse.gm','tse.M','tse.SG,tse.gl','tse.gl.ol','tse.gl.sure','tse.gl.dynamic'))
error
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
a=read.table('error.txt',header=T,sep='\t')
a=read.table('~/desktop/error.txt',header=T,sep='\t')
a
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
library(isotone)
install.packages(isotone)
install.packages('isotone')
libarary(isotone)
library(isotone)
if(!exists("foo", mode="function")) source("util.R")
if(!exists("foo", mode="function")) source("functions.R")
if(!exists("foo", mode="function")) source("functions.R","functions_XKB.R")
if(!exists("foo", mode="function")) source(c("functions.R","functions_XKB.R"))
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
# run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero
# XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero
# XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero
# group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)
# URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero
khat.sure
for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }
sure.vec
sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)
k
sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)
x=bat$X1
v=1/(4*bat$N1)
nbreak=k
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n
suresub
xsub
length(xsub)
xsub[1]
xsub[2]
xsub[3]
length(xsub[3])
length(xsub[1])
xsub1
xsub[1]
sure.spher(xsub,ysub)
sure.spher(xsub[1],ysub[1])
sure.spher(xsub[1],vsub[1])
vsub
apply(sure.spher,xsub,vsub)
apply(sure.spher,xsub[1],vsub[1])
suresub <- mapply(sure.spher,xsub,vsub)
suresub
sum(suresub)
sum(suresub!=NULL)
suresub
suresub==NULL
sum(suresub[5:6])
as.numeric(suresub)
splitby=cut(log(v),breaks=nbreak)
splitby
xsub <- split(x,splitby,drop=T)
xsub
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
error
average
col.names(err)
col.names(error)
col(error)
names(error)
name(error)
names(error)
error
colnames(error)
tse.gl.sure.all <- mean(tse.gl.sure)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
error
average
names
bat.perm <- function(){#
  bat <- bat.raw[1:150,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
bat <- bat.perm()
Groupsure(bat$X1,1/(4 * bat$N1))
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
Groupsure(bat$X1,1/(4 * bat$N1))
GroupSure(bat$X1,1/(4 * bat$N1))
bat.perm <- function(){#
  bat <- bat.raw[1:100,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}
bat.perm <- function(){#
  bat <- bat.raw[1:60,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
bat <- bat.perm()
index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
GroupSure(bat$X1,1/(4 * bat$N1))
ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)
sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
delta.dynamic2=GroupSureMin(bat$X1,1/(4 * bat$N1))
if(!exists("foo", mode="function")) source("functions.R")
if(!exists("foo", mode="function")) source("functions_XKB.R")
if(!exists("foo", mode="function")) source("dynamic_sure.R")
delta.dynamic2=GroupSureMin(bat$X1,1/(4 * bat$N1))
for(i in 1:-2)
print(i)
for(i in 1:0)
print(i)
if(!exists("foo", mode="function")) source("functions.R")
delta.dynamic2=GroupSureMin(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
DynamicSure2=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
GroupSure2<- function(x,v){ #
   c=DynamicSure2(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
delta.dynamic
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
if(!exists("foo", mode="function")) source("functions.R")
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
delta.dynamic
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
bat.perm <- function(){#
  bat <- bat.raw[1:200,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.SG
tse.hat.delta.gl
bat.perm <- function(){#
  bat <- bat.raw[1:500,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)
tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.zero
tse.hat.delta.gm
delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.M
delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero
tse.hat.delta.SG
# num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.gl
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic2
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic2
dim(bat)
a=DynamicSure2(bat$X1,1/(4 * bat$N1))
a
position=a[[1]]#
group=partition(position,1,n)
group=partition(position,1,301)
group
group=c(0, group,n)
group=c(0, group,301)
group
group=unique(group)
group
head(abr)
head(bat)
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:n-d+1){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-d+1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}}#
			}#
		}#
	}#
	list(a,b)#
}
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:n-d+1){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-d+1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}}#
			}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))
DynamicSure2=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			for (k in i:(j-1)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
GroupSure2<- function(x,v){ #
   c=DynamicSure2(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic2
tse.hat.delta.dynamic
tse.hat.delta.gl
tse.hat.delta.SG
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-d+1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}}#
			}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))
dim(bat$x1)
dim(bat)
c=DynamicSureMin(bat$X1,1/(4 * bat$N1))
position=c[[1]]
n=dim(position)[1]
group=partition(position,1,n)
position[1,n]
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic3
301^{2/3}
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=20){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.hat.delta.dynamic3
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=30){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.hat.delta.dynamic3
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=40){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.hat.delta.dynamic3
