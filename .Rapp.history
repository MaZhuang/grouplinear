a=read.table('error.txt',header=T,sep='\t')
a=read.table('~/desktop/error.txt',header=T,sep='\t')
a
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
library(isotone)
install.packages(isotone)
install.packages('isotone')
libarary(isotone)
library(isotone)
if(!exists("foo", mode="function")) source("util.R")
if(!exists("foo", mode="function")) source("functions.R")
if(!exists("foo", mode="function")) source("functions.R","functions_XKB.R")
if(!exists("foo", mode="function")) source(c("functions.R","functions_XKB.R"))
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
# run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero
# XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero
# XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero
# group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)
# URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero
khat.sure
for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }
sure.vec
sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)
k
sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)
x=bat$X1
v=1/(4*bat$N1)
nbreak=k
n <- length(x)#
	splitby=cut(log(v),breaks=nbreak)#
	xsub <- split(x,splitby)#
	vsub <- split(v,splitby)#
	suresub <- mapply(sure.spher,xsub,vsub)   #modified#
	sum(suresub)/n
suresub
xsub
length(xsub)
xsub[1]
xsub[2]
xsub[3]
length(xsub[3])
length(xsub[1])
xsub1
xsub[1]
sure.spher(xsub,ysub)
sure.spher(xsub[1],ysub[1])
sure.spher(xsub[1],vsub[1])
vsub
apply(sure.spher,xsub,vsub)
apply(sure.spher,xsub[1],vsub[1])
suresub <- mapply(sure.spher,xsub,vsub)
suresub
sum(suresub)
sum(suresub!=NULL)
suresub
suresub==NULL
sum(suresub[5:6])
as.numeric(suresub)
splitby=cut(log(v),breaks=nbreak)
splitby
xsub <- split(x,splitby,drop=T)
xsub
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=FALSE)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
error
average
col.names(err)
col.names(error)
col(error)
names(error)
name(error)
names(error)
error
colnames(error)
tse.gl.sure.all <- mean(tse.gl.sure)
bat.perm <- function(){#
  bat <- bat.raw[1:50,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
#dynamic#
c=DynamicSure(bat$X1,1/(4 * bat$N1))#
position=c[[1]]#
n=dim(position)[1]#
group=partition(position,1,n)#
group=c(0, group,n)#
group=unique(group)#
delta.dynamic=dynamic.grouplinear(bat$X1,1/(4 * bat$N1),group)#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
error
average
names
bat.perm <- function(){#
  bat <- bat.raw[1:150,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
bat <- bat.perm()
Groupsure(bat$X1,1/(4 * bat$N1))
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
Groupsure(bat$X1,1/(4 * bat$N1))
GroupSure(bat$X1,1/(4 * bat$N1))
bat.perm <- function(){#
  bat <- bat.raw[1:100,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}
bat.perm <- function(){#
  bat <- bat.raw[1:60,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
bat <- bat.perm()
index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
GroupSure(bat$X1,1/(4 * bat$N1))
ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)
sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
delta.dynamic2=GroupSureMin(bat$X1,1/(4 * bat$N1))
if(!exists("foo", mode="function")) source("functions.R")
if(!exists("foo", mode="function")) source("functions_XKB.R")
if(!exists("foo", mode="function")) source("dynamic_sure.R")
delta.dynamic2=GroupSureMin(bat$X1,1/(4 * bat$N1))
for(i in 1:-2)
print(i)
for(i in 1:0)
print(i)
if(!exists("foo", mode="function")) source("functions.R")
delta.dynamic2=GroupSureMin(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
DynamicSure2=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
GroupSure2<- function(x,v){ #
   c=DynamicSure2(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
delta.dynamic
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
if(!exists("foo", mode="function")) source("functions.R")
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
delta.dynamic
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
bat.perm <- function(){#
  bat <- bat.raw[1:200,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
tse.hat.delta.dynamic2
delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.SG
tse.hat.delta.gl
bat.perm <- function(){#
  bat <- bat.raw[1:500,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)
tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.zero
tse.hat.delta.gm
delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.M
delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero
tse.hat.delta.SG
# num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.gl
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic2
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic2
dim(bat)
a=DynamicSure2(bat$X1,1/(4 * bat$N1))
a
position=a[[1]]#
group=partition(position,1,n)
group=partition(position,1,301)
group
group=c(0, group,n)
group=c(0, group,301)
group
group=unique(group)
group
head(abr)
head(bat)
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:n-d+1){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-d+1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}}#
			}#
		}#
	}#
	list(a,b)#
}
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:n-d+1){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-d+1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}}#
			}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))
DynamicSure2=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			for (k in i:(j-1)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
GroupSure2<- function(x,v){ #
   c=DynamicSure2(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic2
tse.hat.delta.dynamic
tse.hat.delta.gl
tse.hat.delta.SG
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-d+1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}}#
			}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))
dim(bat$x1)
dim(bat)
c=DynamicSureMin(bat$X1,1/(4 * bat$N1))
position=c[[1]]
n=dim(position)[1]
group=partition(position,1,n)
position[1,n]
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=10){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic3
301^{2/3}
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=20){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.hat.delta.dynamic3
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=30){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.hat.delta.dynamic3
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			for (k in i:(j-1)){#
				temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				if (sure>temp){#
					sure=temp#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=sure#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=40){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}#
partition=function(position,i,j){#
	if (position[i,j]==j){#
		return(j)#
	}else if (position[i,j]==i){#
		return(i)#
	}#
	else{#
		a=partition(position,i,position[i,j])#
		b=partition(position,position[i,j],j)#
		return(c(a,position[i,j],b))#
	}#
}#
dynamic.grouplinear <- function(x,v,group){ #nbreak=num of bins#
	ngroup <- length(group)#
	n=length(x)#
	est=rep(0,n)#
	for (i in 1:(ngroup-1)){#
		est[(group[i]+1):group[i+1]]=spher(x[(group[i]+1):group[i+1]],v[(group[i]+1):group[i+1]])#
	}#
	est#
}#
#
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.hat.delta.dynamic3
bat.perm <- function(){#
  bat <- bat.raw[1:500,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
bat.perm <- function(){#
  bat <- bat.raw#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
  bat=bat[index,]
ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
#
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
a=DynamicSure2(bat$X1,1/(4 * bat$N1))#
position=a[[1]]#
group=partition(position,1,301)#
group=c(0, group,301)#
group=unique(group)#
delta.dynamic3=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic3 <- sum(   (  ( bat$X2 - delta.dynamic3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.hat.delta.dynamic3
tse.hat.delta.SG
tse.hat.delta.gl
n=dim(bat)[1]
n
n^{2/3}
delta.dynamic2=GroupSure2(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic2 <- sum(   (  ( bat$X2 - delta.dynamic2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
DynamicSure=function(x,v){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for(i in 1:n){#
		a[i,i]=i#
		b[i,i]=v[i]#
	}#
	for (l in 1:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			for (k in i:(j-1)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}#
		}#
	}#
	list(a,b)#
}#
#
DynamicSureMin=function(x,v,d=40){#
    n <- length(x)#
    a=matrix(rep(0,n*n),ncol=n) ##separation#
	b=a ##value#
	for (i in 1:(n-d+1)){#
		j=i+d-1#
		a[i,j]=j#
		b[i,j]=sure.spher(x[i:j], v[i:j])#
	}#
	for (l in d:(n-1)){#
		if (l %% 20==0){#
		    print(l)#
		}#
		for (i in 1:(n-l)){#
			j=l+i#
			sure=sure.spher(x[i:j], v[i:j])#
		#	print(sure)#
			a[i,j]=j#
			b[i,j]=sure#
			if ((i+d-1)<=(j-d)){#
			for (k in (i+d-1):(j-d)){#
				#temp=sure.spher(x[i:k], v[i:k])+sure.spher(x[(k+1):j], v[(k+1):j])#
				temp=b[i,k]+b[k+1,j]#
				if (b[i,j]>temp){#
				#	print(sure)#
					a[i,j]=k#
					b[i,j]=temp#
				}#
			}}#
		}#
	}#
	list(a,b)#
}
GroupSure<- function(x,v){ #
   c=DynamicSure(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}#
#
GroupSureMin<- function(x,v){ #
   c=DynamicSureMin(x,v)#
   position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)#
   est=dynamic.grouplinear(x,v,group)#
   return(est)#
}
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )
tse.hat.delta.dynamic
bat.perm <- function(){#
  bat <- bat.raw[1:100,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
delta.dynamicMin=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamicMin <- sum(   (  ( bat$X2 - delta.dynamicMin )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin[j] =tse.hat.delta.dynamicMin/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
tse.gl.dynamicMin.all <- mean(tse.gl.dynamicMin)#
#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all,tse.gl.dynamicMin.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic,tse.gl.dynamicMin)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw[1:200,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
delta.dynamicMin=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamicMin <- sum(   (  ( bat$X2 - delta.dynamicMin )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin[j] =tse.hat.delta.dynamicMin/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
tse.gl.dynamicMin.all <- mean(tse.gl.dynamicMin)#
#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all,tse.gl.dynamicMin.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic,tse.gl.dynamicMin)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
n
bat.perm <- function(){#
  bat <- bat.raw[1:300,]#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
delta.dynamicMin=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamicMin <- sum(   (  ( bat$X2 - delta.dynamicMin )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin[j] =tse.hat.delta.dynamicMin/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
tse.gl.dynamicMin.all <- mean(tse.gl.dynamicMin)#
#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all,tse.gl.dynamicMin.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic,tse.gl.dynamicMin)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
n^{1/3}
567^{1/3}
567^{123}
n
567^{2/3}
n=dim(bat)[1]
n
bat.perm <- function(){#
  bat <- bat.raw#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
delta.dynamicMin=GroupSureMin(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamicMin <- sum(   (  ( bat$X2 - delta.dynamicMin )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin[j] =tse.hat.delta.dynamicMin/tse.hat.zero#
#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
tse.gl.dynamicMin.all <- mean(tse.gl.dynamicMin)#
#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all,tse.gl.dynamicMin.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic,tse.gl.dynamicMin)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
tse.gl.dynamicMin2 <- rep(NA,N)#
tse.gl.dynamicMin3 <- rep(NA,N)
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")
j=1
bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]
ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero
c=DynamicSure(bat$X1,1/(4 * bat$N1))
position=c[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)
group
tse.hat.delta.dynamic
tse.hat.delta.gl
cmin=DynamicSureMin(x,v,40)#
   position=cmin[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)
cmin=DynamicSureMin(bat$X1,1/(4 * bat$N1),40)#
   position=cmin[[1]]#
   n=dim(position)[1]#
   group=partition(position,1,n)#
   group=c(0, group,n)#
   group=unique(group)
group
567
567^(2/3)
567^(2/3)*1.5
567^(2/3)*0.5
567^(2/3)*1.2
567^(2/3)*0.8
567^(2/3)*0.9
567^(2/3)*1,1
567^(2/3)*1.1
log(567)
bat.perm <- function(){#
  bat <- bat.raw#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.JS <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
tse.gl.dynamicMin2 <- rep(NA,N)#
tse.gl.dynamicMin3 <- rep(NA,N)#
#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # James-Stein#
  delta.JS <- JS(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.JS <- sum(   (  ( bat$X2 - delta.JS )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.JS[j] <- tse.hat.delta.JS/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
   #position=c[[1]]#
   #n=dim(position)[1]#
   #group=partition(position,1,n)#
   #group=c(0, group,n)#
   #group=unique(group)  #
#
delta.dynamicMin=GroupSureMin(bat$X1,1/(4 * bat$N1),10)#
tse.hat.delta.dynamicMin <- sum(   (  ( bat$X2 - delta.dynamicMin )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin[j] =tse.hat.delta.dynamicMin/tse.hat.zero#
#cmin=DynamicSureMin(bat$X1,1/(4 * bat$N1),40)#
#position=cmin[[1]]#
#n=dim(position)[1]#
#group=partition(position,1,n)#
#group=c(0, group,n)#
#group=unique(group)#
#
delta.dynamicMin2=GroupSureMin(bat$X1,1/(4 * bat$N1),20)#
tse.hat.delta.dynamicMin2 <- sum(   (  ( bat$X2 - delta.dynamicMin2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin2[j] =tse.hat.delta.dynamicMin2/tse.hat.zero#
#
delta.dynamicMin3=GroupSureMin(bat$X1,1/(4 * bat$N1),30)#
tse.hat.delta.dynamicMin3 <- sum(   (  ( bat$X2 - delta.dynamicMin3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin3[j] =tse.hat.delta.dynamicMin3/tse.hat.zero#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.JS.all <- mean(tse.JS)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
tse.gl.dynamicMin.all <- mean(tse.gl.dynamicMin)#
tse.gl.dynamicMin2.all <- mean(tse.gl.dynamicMin2)#
tse.gl.dynamicMin3.all <- mean(tse.gl.dynamicMin3)#
average=c(tse.gm.all,tse.JS.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all,tse.gl.dynamicMin.all,tse.gl.dynamicMin2.all,tse.gl.dynamicMin3.all )#
error=cbind(tse.gm,tse.JS,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic,tse.gl.dynamicMin,tse.gl.dynamicMin2,tse.gl.dynamicMin3)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 3# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
tse.gl.dynamicMin2 <- rep(NA,N)#
tse.gl.dynamicMin3 <- rep(NA,N)#
#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
   #position=c[[1]]#
   #n=dim(position)[1]#
   #group=partition(position,1,n)#
   #group=c(0, group,n)#
   #group=unique(group)  #
#
delta.dynamicMin=GroupSureMin(bat$X1,1/(4 * bat$N1),10)#
tse.hat.delta.dynamicMin <- sum(   (  ( bat$X2 - delta.dynamicMin )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin[j] =tse.hat.delta.dynamicMin/tse.hat.zero#
#cmin=DynamicSureMin(bat$X1,1/(4 * bat$N1),40)#
#position=cmin[[1]]#
#n=dim(position)[1]#
#group=partition(position,1,n)#
#group=c(0, group,n)#
#group=unique(group)#
#
delta.dynamicMin2=GroupSureMin(bat$X1,1/(4 * bat$N1),20)#
tse.hat.delta.dynamicMin2 <- sum(   (  ( bat$X2 - delta.dynamicMin2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin2[j] =tse.hat.delta.dynamicMin2/tse.hat.zero#
#
delta.dynamicMin3=GroupSureMin(bat$X1,1/(4 * bat$N1),30)#
tse.hat.delta.dynamicMin3 <- sum(   (  ( bat$X2 - delta.dynamicMin3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin3[j] =tse.hat.delta.dynamicMin3/tse.hat.zero#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
tse.gl.dynamicMin.all <- mean(tse.gl.dynamicMin)#
tse.gl.dynamicMin2.all <- mean(tse.gl.dynamicMin2)#
tse.gl.dynamicMin3.all <- mean(tse.gl.dynamicMin3)#
average=c(tse.gm.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all,tse.gl.dynamicMin.all,tse.gl.dynamicMin2.all,tse.gl.dynamicMin3.all )#
error=cbind(tse.gm,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic,tse.gl.dynamicMin,tse.gl.dynamicMin2,tse.gl.dynamicMin3)#
#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
bat.perm <- function(){#
  bat <- bat.raw#
  bat$N1 <- bat$AB.4. + bat$AB.5. + bat$AB.6.  # total number at-bats for 1st period#
  bat$N2 <- bat$AB.7. + bat$AB.8. + bat$AB.9.10.  # total number at-bats for 2nd period#
  bat$H1 <- bat$H.4. + bat$H.5. + bat$H.6.  # total number hits for 1st period#
  bat$H2 <- bat$H.7. + bat$H.8. + bat$H.9.10.  # total number hits for 2nd period#
  # bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  # bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  # bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  # bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <- bat[bat$N1 > 10,]  # keep only records with N1>=11  #
  bat$H1.perm <- NA#
  for(i in 1:dim(bat)[1]){#
    bat$H1.perm[i] <- rhyper(nn=1,m=bat$H1[i] + bat$H2[i],n=bat$N1[i] + bat$N2[i] -bat$H1[i] - bat$H2[i],k=bat$N1[i])#
  }#
  bat$H2.perm <- bat$H1 + bat$H2 - bat$H1.perm#
  # head(cbind(bat$H1,bat$H1.perm,bat$H2,bat$H2.perm))#
  bat$H1 <- bat$H1.perm #
  bat$H2 <- bat$H2.perm #
  bat$R1 <- bat$H1/bat$N1  # batting avg for 1st period#
  bat$R2 <- bat$H2/bat$N2  # batting avg for 2nd period#
  bat$X1 <- asin(  sqrt( (bat$H1+1/4)/(bat$N1+1/2) )  )  # transformed batting avg for 1st period#
  bat$X2 <- asin(  sqrt( (bat$H2+1/4)/(bat$N2+1/2) )  )  # transformed batting avg for 2nd period#
  bat <-  bat[,c('First.Name','Last.Name','Pitcher.','N1','N2','H1','H2','X1','X2')]#
}#
#
N <- 1# num shuffling rounds#
if(!exists("foo", mode="function")) source("functions.R")#
if(!exists("foo", mode="function")) source("functions_XKB.R")#
if(!exists("foo", mode="function")) source("dynamic_sure.R")#
#
## all batters#
#
tse.gm <- rep(NA,N)#
tse.JS <- rep(NA,N)#
tse.M <- rep(NA,N)#
tse.SG <- rep(NA,N)#
tse.gl <- rep(NA,N)#
tse.gl.ol <- rep(NA,N)#
tse.gl.sure <- rep(NA,N)#
tse.gl.dynamic <- rep(NA,N)#
tse.gl.dynamicMin <- rep(NA,N)#
tse.gl.dynamicMin2 <- rep(NA,N)#
tse.gl.dynamicMin3 <- rep(NA,N)#
#
path=getwd()#
datapath=paste(path,'Brown_batting_data.txt',sep='/')#
bat.raw <- read.table(datapath, header=TRUE, sep=",", quote="")#
#
for(j in 1:N){#
  bat <- bat.perm()#
  cat('Loop:',j)#
  index=order(bat$N1,decreasing=TRUE)#
#
  bat=bat[index,]#
  n=dim(bat)[1]#
  # estimating TSE for various estimators#
  # run: functions.R(current folder), functions_XKB.R#
  ind <- bat$N2>10  # indicator for records with N2>=11 (among those with N1>=11)#
  tse.hat.zero <- sum(   (  ( bat$X2 - bat$X1 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  # grand mean#
  tse.hat.delta.gm <- sum(   (  ( bat$X2 - mean(bat$X1) )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gm[j] <- tse.hat.delta.gm/tse.hat.zero#
  # James-Stein#
  delta.JS <- JS(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.JS <- sum(   (  ( bat$X2 - delta.JS )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.JS[j] <- tse.hat.delta.JS/tse.hat.zero#
  # XKB theta.hat.M#
  delta.M <- thetahat.M(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.M <- sum(   (  ( bat$X2 - delta.M )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.M[j] <- tse.hat.delta.M/tse.hat.zero#
  # XKB theta.hat.SG#
  delta.SG <- thetahat.SG(bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.SG <- sum(   (  ( bat$X2 - delta.SG )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.SG[j] <- tse.hat.delta.SG/tse.hat.zero#
  # group-linear  #
    # num bins = n^1/3#
  delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl[j] <- tse.hat.delta.gl/tse.hat.zero#
    # oracle#
  rel.tse.breaks <- rep(NA,20)#
  delta.gl <- spher(x=bat$X1, v=1/(4 * bat$N1))#
  tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  rel.tse.breaks[1] <- tse.hat.delta.gl/tse.hat.zero#
  for(i in 2:20){#
    delta.gl <- grouplinear(x=bat$X1, v=1/(4 * bat$N1),nbreak = i)#
    tse.hat.delta.gl <- sum(   (  ( bat$X2 - delta.gl )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
    rel.tse.breaks[i] <- tse.hat.delta.gl/tse.hat.zero#
  }#
  tse.gl.ol[j] <- min(rel.tse.breaks)#
#   k.ol <- which.min(rel.tse.breaks)  #
    # URE#
  # i) split into k intervals of equal length on log(v)#
  min.diff <- min(diff( sort(log( 1/(4 * bat$N1) )) )[diff( sort(log( 1/(4 * bat$N1) )) )>0])  # min_{i,j: v_i != v_j} |v_i-v_j|#
  kmax <- ceiling( diff(range(log( 1/(4 * bat$N1) )))/min.diff )#
  sure.vec <- rep(NA,kmax)#
  sure.vec[1] <- sure.spher(bat$X1,1/(4 * bat$N1))#
  for (k in 2:30){#
    sure.vec[k] <- sure.grouplinear(bat$X1,1/(4 * bat$N1),nbreak=k)#
  }#
  khat.sure <- which.min(sure.vec)#
  delta.gl.sure <- if(khat.sure>1) grouplinear( bat$X1,1/(4 * bat$N1),nbreak=khat.sure) else spher( bat$X1,1/(4 * bat$N1))#
  tse.hat.delta.gl.sure <- sum(   (  ( bat$X2 - delta.gl.sure )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
  tse.gl.sure[j] <- tse.hat.delta.gl.sure/tse.hat.zero#
delta.dynamic=GroupSure.zero(bat$X1,1/(4 * bat$N1))#
tse.hat.delta.dynamic <- sum(   (  ( bat$X2 - delta.dynamic )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamic[j] =tse.hat.delta.dynamic/tse.hat.zero#
#
   #position=c[[1]]#
   #n=dim(position)[1]#
   #group=partition(position,1,n)#
   #group=c(0, group,n)#
   #group=unique(group)  #
#
delta.dynamicMin=GroupSureMin.zero(bat$X1,1/(4 * bat$N1),40)#
tse.hat.delta.dynamicMin <- sum(   (  ( bat$X2 - delta.dynamicMin )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin[j] =tse.hat.delta.dynamicMin/tse.hat.zero#
#cmin=DynamicSureMin(bat$X1,1/(4 * bat$N1),40)#
#position=cmin[[1]]#
#n=dim(position)[1]#
#group=partition(position,1,n)#
#group=c(0, group,n)#
#group=unique(group)#
#
delta.dynamicMin2=GroupSureMin(bat$X1,1/(4 * bat$N1),50)#
tse.hat.delta.dynamicMin2 <- sum(   (  ( bat$X2 - delta.dynamicMin2 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin2[j] =tse.hat.delta.dynamicMin2/tse.hat.zero#
#
delta.dynamicMin3=GroupSureMin(bat$X1,1/(4 * bat$N1),60)#
tse.hat.delta.dynamicMin3 <- sum(   (  ( bat$X2 - delta.dynamicMin3 )^2 - 1/ ( 4 * bat$N2 )  )[ind]   )#
tse.gl.dynamicMin3[j] =tse.hat.delta.dynamicMin3/tse.hat.zero#
}#
#
tse.gm.all <- mean(tse.gm)#
tse.JS.all <- mean(tse.JS)#
tse.M.all <- mean(tse.M)#
tse.SG.all <- mean(tse.SG)#
tse.gl.all <- mean(tse.gl)#
tse.gl.ol.all <- mean(tse.gl.ol)#
tse.gl.sure.all <- mean(tse.gl.sure)#
tse.gl.dynamic.all <- mean(tse.gl.dynamic)#
tse.gl.dynamicMin.all <- mean(tse.gl.dynamicMin)#
tse.gl.dynamicMin2.all <- mean(tse.gl.dynamicMin2)#
tse.gl.dynamicMin3.all <- mean(tse.gl.dynamicMin3)#
average=c(tse.gm.all,tse.JS.all,tse.M.all,tse.SG.all,tse.gl.all,tse.gl.ol.all,tse.gl.sure.all,tse.gl.dynamic.all,tse.gl.dynamicMin.all,tse.gl.dynamicMin2.all,tse.gl.dynamicMin3.all )#
error=cbind(tse.gm,tse.JS,tse.M,tse.SG,tse.gl,tse.gl.ol,tse.gl.sure,tse.gl.dynamic,tse.gl.dynamicMin,tse.gl.dynamicMin2,tse.gl.dynamicMin3)#
names=colnames(error)#
write.table(average, "~/desktop/average.txt",sep="\t",row.names=names)#
write.table(error, "~/desktop/error.txt",sep="\t",row.names=FALSE)
